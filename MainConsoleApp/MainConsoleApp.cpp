#include <iostream>
#include <windows.h>
#include <stdio.h>

#define THREAD_COUNT 5 // #define — это команда для препроцессора. Препроцессор обрабатывает исходный код ещё до того, как начнётся компиляция.

using namespace std;

CRITICAL_SECTION g_ConsoleLock;

HANDLE hEvent; // Наше событие

// Функция, которую будет выполнять поток.
// Она ОБЯЗАТЕЛЬНО должна возвращать DWORD и принимать LPVOID.

// Просто для потоков
DWORD WINAPI MyThreadFunction(LPVOID lpParam) {

    // Приводим рандомный тип данных к int-указателю, после при помощи еще одного указателя получаем само int-число
    int ID = *((int*)lpParam); 

    for (int i = 0; i < 5; i++) {
        printf("Поток %d работает... шаг %d\n", ID, i);
        Sleep(100);
    }

    return 0;
}
// Для массива потоков
DWORD WINAPI WorkerFunction(LPVOID lpParam) {

    // Безопасное приведение указателя к числу
    int id = (int)(intptr_t)lpParam; 
    printf("Поток #%d начал...\n", id);

    // Имитируем работу разной длительности
    Sleep(1000 + (id * 200));
    printf("Поток #%d закончил!\n", id);

    return 0;
}
// Для потоков в критической секции
DWORD WINAPI Worker(LPVOID lpParam) {

    int id = (int)(intptr_t)lpParam;

    for (int i = 0; i < 5; i++) {
        // Входим в секцию. Если другой поток уже там, этот "заснет" и будет ждать.
        EnterCriticalSection(&g_ConsoleLock);

        // --- КРИТИЧЕСКИЙ УЧАСТОК ---
        printf("Поток #%d начал выводить долгое сообщение...\n", id);
        Sleep(50); // Имитируем задержку
        printf("Потом #%d Закончил выводить его сообщение. Шаг: %d\n", id, i);
        // ---------------------------

        // Выходим и даем дорогу другим
        LeaveCriticalSection(&g_ConsoleLock);

        Sleep(10); // Небольшая пауза, чтобы дать шанс другим потокам
    }
    return 0;
}
// Для события для потоков
DWORD WINAPI DataProducer(LPVOID lpParam) {

    printf("[Говорильщик] Я... эээ... Скачиваю большой толстый файл...\n");
    Sleep(3000); // Имитация долгой работы (3 секунды)
    printf("[Говорильщик] Файл скачан, о боже! Сигнализация нах...\n");

    // Устанавливаем событие в сигнальное состояние ("зажигаем зеленый")
    SetEvent(hEvent);

    return 0;
}
DWORD WINAPI DataConsumer(LPVOID lpParam) {

    printf("[Обработчик] Я типо ждун, жду файл...\n");

    // Ждем, пока событие станет сигнальным (аналог WaitForSingleObject для потоков)
    WaitForSingleObject(hEvent, INFINITE);

    printf("[Обработчик] Ахуенно! Я вижу файл. Начинаю обработку...\n");

    return 0;
}

int main()
{
    setlocale(LC_ALL, "RUS");

    // ====================================================================================================================================
    //                                  ПРОСТОЙ ПРИМЕР ПОТОКА (ОПИСАНА САМАЯ БАЗА ДЛЯ ПОТОКОВ)
    // ====================================================================================================================================

    int id1 = 1;
    int id2 = 2;

    //Объявляются две переменные типа HANDLE — это специальный тип в Windows, который хранит дескриптор объекта.
    //Дескриптор — это как «удостоверение» для управления объектом

    HANDLE hThread1, hThread2;
    DWORD dwThreadId1, dwThreadId2;

    // 1. Создаем первый поток
    hThread1 = CreateThread(
        NULL,                   // Атрибуты защиты (по умолчанию)
        0,                      // Размер стека (по умолчанию)
        MyThreadFunction,       // Имя функции потока
        &id1,                   // Аргумент для функции
        0,                      // Флаги создания (запустить сразу)
        &dwThreadId1            // Переменная для ID потока
    );

    

    // 2. Создаем второй поток
    hThread2 = CreateThread(NULL, 0, MyThreadFunction, &id2, 0, &dwThreadId2);

    // Проверка на ошибки
    if (hThread1 == NULL || hThread2 == NULL) {
        return 1;
    }

    // 3. Ждем, пока оба потока закончат работу (аналог join)
    // INFINITE означает, что ждем сколько угодно долго
    WaitForSingleObject(hThread1, INFINITE);
    WaitForSingleObject(hThread2, INFINITE);

    // 4. Закрываем дескрипторы (освобождаем ресурсы)
    CloseHandle(hThread1);
    CloseHandle(hThread2);

    printf("Все потоки закончили.\n");



    // ====================================================================================================================================
    //                  РАБОТА С НЕСКОЛЬКИМИ ПОТОКАМИ + ЗАЩИТА ВЫХОДНЫХ ДАННЫХ В КОНСОЛЬ ПРИ ПОМОЩИ КРИТИЧЕСКОЙ СЕКЦИИ
    // ====================================================================================================================================

    HANDLE hThreads[THREAD_COUNT]; // Массив для хранения хендлов всех потоков

    // Инициализируем секцию перед использованием
    InitializeCriticalSection(&g_ConsoleLock);

    printf("Создание потоков...\n");

    // Для функции Worker:
    for (int i = 0; i < 5; i++) 
    {
        hThreads[i] = CreateThread(NULL, 0, Worker, (LPVOID)(intptr_t)i, 0, NULL);
    }

    // Для функции WorkerFunction:
    /*for (int i = 0; i < THREAD_COUNT; i++) {
        hThreads[i] = CreateThread(
            NULL,
            0,
            WorkerFunction,
            (LPVOID)(intptr_t)i, // Передаем индекс как ID
            0,
            NULL
        );

        if (hThreads[i] == NULL) {
            printf("Ошибка создания потока %d\n", i);
            return 1;
        }
    }*/

    // Ждем, пока ВСЕ объекты из массива перейдут в сигнальное состояние
    printf("\nОсновной поток ожидает всех остальных...\n\n");

    WaitForMultipleObjects(
        THREAD_COUNT,           // 1. Сколько объектов ждем
        hThreads,               // 2. Указатель на массив хендлов
        TRUE,                   // 3. Ждать ВСЕХ (TRUE) или любого первого (FALSE)?
        INFINITE                // 4. Таймаут (бесконечно)
    );

    printf("\nВсе потоки закончили. Очистка...\n");

    // Удаляем секцию если она больше не нужна
    DeleteCriticalSection(&g_ConsoleLock); 

    // Не забываем закрыть все хендлы
    for (int i = 0; i < THREAD_COUNT; i++) {
        CloseHandle(hThreads[i]);
    }



    // ====================================================================================================================================
    //                         РАБОТА С СОБЫТИЯМИ (ОНИ МОГУТ ТЫКАТЬ ПРОЧИЕ ПОТОКИ, ТЕМ САМЫМ ЗАПУСКАЯ ИХ)
    // ====================================================================================================================================
    
    // Создаем событие
    hEvent = CreateEvent(
        NULL,               // Атрибуты защиты
        FALSE,              // bManualReset: FALSE = автосброс (сразу станет красным после прохода одного потока)
        FALSE,              // bInitialState: FALSE = изначально красный свет
        NULL                // Имя события
    );

    HANDLE threads[2];

    threads[0] = CreateThread(NULL, 0, DataConsumer, NULL, 0, NULL);
    threads[1] = CreateThread(NULL, 0, DataProducer, NULL, 0, NULL);

    WaitForMultipleObjects(2, threads, TRUE, INFINITE);

    // Закрываем хэндлы.
    CloseHandle(hEvent);
    for (int i = 0; i < 2; i++) {
        CloseHandle(threads[i]);
    }

    return 0;
}



/* 
========================= СПРАВКА ФУНКЦИИ ПОТОКА =========================
DWORD — это просто unsigned long (32 битное целое число без знака)
WINAPI - указывает соглашение о вызове (как именно аргументы кладутся в стек процессора).
LPVOID - универсальный указатель, чтобы ты мог передать в поток структуру, массив или число (void*)
==========================================================================
*/

/*
========================= СПРАВКА СОЗДАНИЯ ПОТОКА =========================
Первый параметр lpThreadAttributes:
    Указатель на структуру с атрибутами защиты. Если передать NULL, используются параметры
    защиты по умолчанию, и дескриптор не может быть унаследован дочерними процессами.

Второй параметр dwStackSize:
    Размер стека для нового потока в байтах. 0 означает, что используется размер стека,
    заданный в исполняемом файле (обычно 1 МБ).

Третий параметр lpStartAddress:
    Указатель на функцию, которая будет выполняться в новом потоке. Это имя нашей функции
    (она должна иметь сигнатуру DWORD WINAPI MyThreadFunction(LPVOID lpParam)).

Четвертый параметр lpParameter:
    Указатель на данные, которые нужно передать в поток. Здесь передаётся адрес переменной id1.
    Внутри функции потока этот адрес будет доступен через параметр lpParam.
    Таким образом поток сможет прочитать значение id1.

Пятый параметр dwCreationFlags:
    Флаги создания потока. 0 означает, что поток запускается сразу же после создания.
    Если бы мы указали CREATE_SUSPENDED, поток создался бы в приостановленном
    состоянии, и его пришлось бы запускать отдельно.

Шестой параметр lpThreadId:
    Указатель на переменную типа DWORD, в которую функция запишет идентификатор потока,
    присвоенный системой. Если идентификатор не нужен, можно передать NULL. 
===========================================================================
*/

/*
* ======================= СПРАВКА СОЗДАНИЯ СОБЫТИЯ ========================
Второй аргумент bManualReset: 
    Если поставить TRUE, то когда ты "включишь свет" (SetEvent), он будет гореть вечно,
    пока ты вручную не выключишь его через ResetEvent. Если поставить FALSE (автосброс),
    то как только один поток "проскочит" через ожидание, событие само захлопнется (снова станет красным).

Третий аргумент bInitialState:
    Если TRUE, событие сразу будет "зеленым".
===========================================================================
*/